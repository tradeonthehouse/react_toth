{"ast":null,"code":"import { __read } from 'tslib';\nimport { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.js';\nimport { MotionConfigContext } from '../context/MotionConfigContext.js';\nimport { useConstant } from '../utils/use-constant.js';\n\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * export function MyComponent() {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <Frame scale={scale} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\nfunction useMotionValue(initial) {\n  var value = useConstant(function () {\n    return motionValue(initial);\n  });\n  /**\r\n   * If this motion value is being used in static mode, like on\r\n   * the Framer canvas, force components to rerender when the motion\r\n   * value is updated.\r\n   */\n  var isStatic = useContext(MotionConfigContext).isStatic;\n  if (isStatic) {\n    var _a = __read(useState(initial), 2),\n      setLatest_1 = _a[1];\n    useEffect(function () {\n      return value.onChange(setLatest_1);\n    }, []);\n  }\n  return value;\n}\nexport { useMotionValue };","map":null,"metadata":{},"sourceType":"module"}