{"ast":null,"code":"import * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { useFeatures } from './features/use-features.js';\nimport { MotionConfigContext } from '../context/MotionConfigContext.js';\nimport { MotionContext } from '../context/MotionContext/index.js';\nimport { useVisualElement } from './utils/use-visual-element.js';\nimport { useMotionRef } from './utils/use-motion-ref.js';\nimport { useCreateMotionContext } from '../context/MotionContext/create.js';\nimport { loadFeatures } from './features/definitions.js';\nimport { isBrowser } from '../utils/is-browser.js';\n\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n *\r\n * @internal\r\n */\nfunction createMotionComponent(_a) {\n  var preloadedFeatures = _a.preloadedFeatures,\n    createVisualElement = _a.createVisualElement,\n    useRender = _a.useRender,\n    useVisualState = _a.useVisualState,\n    Component = _a.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    /**\r\n     * If we're rendering in a static environment, we only visually update the component\r\n     * as a result of a React-rerender rather than interactions or animations. This\r\n     * means we don't need to load additional memory structures like VisualElement,\r\n     * or any gesture/animation features.\r\n     */\n    var isStatic = useContext(MotionConfigContext).isStatic;\n    var features = null;\n    /**\r\n     * Create the tree context. This is memoized and will only trigger renders\r\n     * when the current tree variant changes in static mode.\r\n     */\n    var context = useCreateMotionContext(props, isStatic);\n    /**\r\n     *\r\n     */\n    var visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      /**\r\n       * Create a VisualElement for this component. A VisualElement provides a common\r\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n       * providing a way of rendering to these APIs outside of the React render loop\r\n       * for more performant animations and interactions\r\n       */\n      context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n      /**\r\n       * Load Motion gesture and animation features. These are rendered as renderless\r\n       * components so each feature can optionally make use of React lifecycle methods.\r\n       *\r\n       * TODO: The intention is to move these away from a React-centric to a\r\n       * VisualElement-centric lifecycle scheme.\r\n       */\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    /**\r\n     * The mount order and hierarchy is specific to ensure our element ref\r\n     * is hydrated by the time features fire their effects.\r\n     */\n    return React.createElement(React.Fragment, null, React.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);\n  }\n  return forwardRef(MotionComponent);\n}\nexport { createMotionComponent };","map":null,"metadata":{},"sourceType":"module"}