{"ast":null,"code":"export const findClosestEnabledDate = _ref => {\n  let {\n    date,\n    disableFuture,\n    disablePast,\n    maxDate,\n    minDate,\n    shouldDisableDate,\n    utils\n  } = _ref;\n  const today = utils.startOfDay(utils.date());\n  if (disablePast && utils.isBefore(minDate, today)) {\n    minDate = today;\n  }\n  if (disableFuture && utils.isAfter(maxDate, today)) {\n    maxDate = today;\n  }\n  let forward = date;\n  let backward = date;\n  if (utils.isBefore(date, minDate)) {\n    forward = utils.date(minDate);\n    backward = null;\n  }\n  if (utils.isAfter(date, maxDate)) {\n    if (backward) {\n      backward = utils.date(maxDate);\n    }\n    forward = null;\n  }\n  while (forward || backward) {\n    if (forward && utils.isAfter(forward, maxDate)) {\n      forward = null;\n    }\n    if (backward && utils.isBefore(backward, minDate)) {\n      backward = null;\n    }\n    if (forward) {\n      if (!shouldDisableDate(forward)) {\n        return forward;\n      }\n      forward = utils.addDays(forward, 1);\n    }\n    if (backward) {\n      if (!shouldDisableDate(backward)) {\n        return backward;\n      }\n      backward = utils.addDays(backward, -1);\n    }\n  } // fallback to today if no enabled days\n\n  return utils.date();\n};\nexport function parsePickerInputValue(utils, value) {\n  const parsedValue = utils.date(value);\n  return utils.isValid(parsedValue) ? parsedValue : null;\n}\nexport function parseRangeInputValue(utils) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [null, null];\n  return value.map(date => !utils.isValid(date) || date === null ? null : utils.startOfDay(utils.date(date)));\n}\nexport const isRangeValid = (utils, range) => {\n  return Boolean(range && range[0] && range[1] && !utils.isBefore(range[1], range[0]));\n};\nexport const isWithinRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isWithinRange(day, range);\n};\nexport const isStartOfRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isSameDay(day, range[0]);\n};\nexport const isEndOfRange = (utils, day, range) => {\n  return isRangeValid(utils, range) && utils.isSameDay(day, range[1]);\n};\nexport const validateDate = (utils, value, _ref2) => {\n  let {\n    disablePast,\n    disableFuture,\n    minDate,\n    maxDate,\n    shouldDisableDate\n  } = _ref2;\n  const now = utils.date();\n  const date = utils.date(value);\n  if (date === null) {\n    return null;\n  }\n  switch (true) {\n    case !utils.isValid(value):\n      return 'invalidDate';\n    case Boolean(shouldDisableDate && shouldDisableDate(date)):\n      return 'shouldDisableDate';\n    case Boolean(disableFuture && utils.isAfterDay(date, now)):\n      return 'disableFuture';\n    case Boolean(disablePast && utils.isBeforeDay(date, now)):\n      return 'disablePast';\n    case Boolean(minDate && utils.isBeforeDay(date, minDate)):\n      return 'minDate';\n    case Boolean(maxDate && utils.isAfterDay(date, maxDate)):\n      return 'maxDate';\n    default:\n      return null;\n  }\n};\nexport const validateDateRange = (utils, value, dateValidationProps) => {\n  const [start, end] = value; // for partial input\n\n  if (start === null || end === null) {\n    return [null, null];\n  }\n  const dateValidations = [validateDate(utils, start, dateValidationProps), validateDate(utils, end, dateValidationProps)];\n  if (dateValidations[0] || dateValidations[1]) {\n    return dateValidations;\n  }\n  if (!isRangeValid(utils, [utils.date(start), utils.date(end)])) {\n    return ['invalidRange', 'invalidRange'];\n  }\n  return [null, null];\n};","map":null,"metadata":{},"sourceType":"module"}