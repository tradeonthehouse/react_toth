{"ast":null,"code":"import { __spreadArray, __read } from 'tslib';\nimport sync, { flushSync } from 'framesync';\nimport { collectProjectingAncestors, updateLayoutMeasurement } from '../../../render/dom/projection/utils.js';\nimport { batchLayout, flushLayout } from '../../../render/dom/utils/batch-layout.js';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n\n/**\r\n * Default handlers for batching VisualElements\r\n */\nvar defaultHandler = {\n  layoutReady: function (child) {\n    return child.notifyLayoutReady();\n  }\n};\n/**\r\n * Create a batcher to process VisualElements\r\n */\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function (child) {\n      return queue.add(child);\n    },\n    flush: function (_a) {\n      var _b = _a === void 0 ? defaultHandler : _a,\n        layoutReady = _b.layoutReady,\n        parent = _b.parent;\n      batchLayout(function (read, write) {\n        var order = Array.from(queue).sort(compareByDepth);\n        var ancestors = parent ? collectProjectingAncestors(parent) : [];\n        write(function () {\n          var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order));\n          allElements.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          order.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          ancestors.forEach(function (element) {\n            return element.restoreTransform();\n          });\n          order.forEach(layoutReady);\n        });\n        read(function () {\n          /**\r\n           * After all children have started animating, ensure any Entering components are set to Present.\r\n           * If we add deferred animations (set up all animations and then start them in two loops) this\r\n           * could be moved to the start loop. But it needs to happen after all the animations configs\r\n           * are generated in AnimateSharedLayout as this relies on presence data\r\n           */\n          order.forEach(function (child) {\n            if (child.isPresent) child.presence = Presence.Present;\n          });\n        });\n        write(function () {\n          /**\r\n           * Starting these animations will have queued jobs on the frame loop. In some situations,\r\n           * like when removing an element, these will be processed too late after the DOM is manipulated,\r\n           * leaving a flash of incorrectly-projected content. By manually flushing these jobs\r\n           * we ensure there's no flash.\r\n           */\n          flushSync.preRender();\n          flushSync.render();\n        });\n        read(function () {\n          /**\r\n           * Schedule a callback at the end of the following frame to assign the latest projection\r\n           * box to the prevViewportBox snapshot. Once global batching is in place this could be run\r\n           * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\r\n           * child attempts to calculate its previous relative position against a prevViewportBox\r\n           * it will be against its latest projection box instead, as the snapshot is useless beyond this\r\n           * render.\r\n           */\n          sync.postRender(function () {\n            return order.forEach(assignProjectionToSnapshot);\n          });\n          queue.clear();\n        });\n      });\n      // TODO: Need to find a layout-synchronous way of flushing this\n      flushLayout();\n    }\n  };\n}\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\nexport { createBatcher };","map":null,"metadata":{},"sourceType":"module"}