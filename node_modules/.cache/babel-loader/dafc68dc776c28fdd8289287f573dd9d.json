{"ast":null,"code":"import PropTypes from 'prop-types';\nimport { exactProp } from '@material-ui/utils';\nimport withWidth, { isWidthDown, isWidthUp } from './withWidth';\nimport useTheme from '../styles/useTheme';\n/**\r\n * @ignore - internal component.\r\n */\n\nfunction HiddenJs(props) {\n  const {\n    children,\n    only,\n    width\n  } = props;\n  const theme = useTheme();\n  let visible = true; // `only` check is faster to get out sooner if used.\n\n  if (only) {\n    if (Array.isArray(only)) {\n      for (let i = 0; i < only.length; i += 1) {\n        const breakpoint = only[i];\n        if (width === breakpoint) {\n          visible = false;\n          break;\n        }\n      }\n    } else if (only && width === only) {\n      visible = false;\n    }\n  } // Allow `only` to be combined with other props. If already hidden, no need to check others.\n\n  if (visible) {\n    // determine visibility based on the smallest size up\n    for (let i = 0; i < theme.breakpoints.keys.length; i += 1) {\n      const breakpoint = theme.breakpoints.keys[i];\n      const breakpointUp = props[`${breakpoint}Up`];\n      const breakpointDown = props[`${breakpoint}Down`];\n      if (breakpointUp && isWidthUp(breakpoint, width) || breakpointDown && isWidthDown(breakpoint, width)) {\n        visible = false;\n        break;\n      }\n    }\n  }\n  if (!visible) {\n    return null;\n  }\n  return children;\n}\nHiddenJs.propTypes = {\n  /**\r\n   * The content of the component.\r\n   */\n  children: PropTypes.node,\n  /**\r\n   * @ignore\r\n   */\n  className: PropTypes.string,\n  /**\r\n   * Specify which implementation to use.  'js' is the default, 'css' works better for\r\n   * server-side rendering.\r\n   */\n  implementation: PropTypes.oneOf(['js', 'css']),\n  /**\r\n   * You can use this prop when choosing the `js` implementation with server-side rendering.\r\n   *\r\n   * As `window.innerWidth` is unavailable on the server,\r\n   * we default to rendering an empty component during the first mount.\r\n   * You might want to use a heuristic to approximate\r\n   * the screen width of the client browser screen width.\r\n   *\r\n   * For instance, you could be using the user-agent or the client-hints.\r\n   * https://caniuse.com/#search=client%20hint\r\n   */\n  initialWidth: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),\n  /**\r\n   * If `true`, screens this size and down are hidden.\r\n   */\n  lgDown: PropTypes.bool,\n  /**\r\n   * If `true`, screens this size and up are hidden.\r\n   */\n  lgUp: PropTypes.bool,\n  /**\r\n   * If `true`, screens this size and down are hidden.\r\n   */\n  mdDown: PropTypes.bool,\n  /**\r\n   * If `true`, screens this size and up are hidden.\r\n   */\n  mdUp: PropTypes.bool,\n  /**\r\n   * Hide the given breakpoint(s).\r\n   */\n  only: PropTypes.oneOfType([PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']), PropTypes.arrayOf(PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']))]),\n  /**\r\n   * If `true`, screens this size and down are hidden.\r\n   */\n  smDown: PropTypes.bool,\n  /**\r\n   * If `true`, screens this size and up are hidden.\r\n   */\n  smUp: PropTypes.bool,\n  /**\r\n   * @ignore\r\n   * width prop provided by withWidth decorator.\r\n   */\n  width: PropTypes.string.isRequired,\n  /**\r\n   * If `true`, screens this size and down are hidden.\r\n   */\n  xlDown: PropTypes.bool,\n  /**\r\n   * If `true`, screens this size and up are hidden.\r\n   */\n  xlUp: PropTypes.bool,\n  /**\r\n   * If `true`, screens this size and down are hidden.\r\n   */\n  xsDown: PropTypes.bool,\n  /**\r\n   * If `true`, screens this size and up are hidden.\r\n   */\n  xsUp: PropTypes.bool\n};\nif (process.env.NODE_ENV !== 'production') {\n  HiddenJs.propTypes = exactProp(HiddenJs.propTypes);\n}\nexport default withWidth()(HiddenJs);","map":null,"metadata":{},"sourceType":"module"}